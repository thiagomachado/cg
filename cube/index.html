<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cubos</title>
		<meta charset="utf-8">
		<style>
			body
      {
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
      canvas
      {
        height: 100%;
        width: 100%;
      }
		</style>
    <script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CanvasRenderer.js"></script>
		<script src="js/Projector.js"></script>
		<script src="js/Detector.js"></script>


	</head>
	<body>
    <script >

					var camera, controls, scene, renderer, light;
					var objects = [];
					init();
					function init()
					{

							camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500000 );
							camera.position.set( 0, 200, 500 );
							//Controle de camera
							controls = new THREE.TrackballControls(camera);
							controls.rotateSpeed = 5.0;
							controls.zoomSpeed = 0.1;
							controls.panSpeed = 2.0;
							controls.noZoom = false;
							controls.noRotate = false;
							controls.noPan = false;
							controls.staticMoving = false;
							controls.dynamicDampingFactor = 0.3;
							controls.enabled = true;

							scene = new THREE.Scene();

							// Verifica se tem renderer webgl, caso n√£o tenha exibe com Canvas
							if ( Detector.webgl )
								renderer = new THREE.WebGLRenderer( {antialias:true} );
							else
								renderer = new THREE.CanvasRenderer();

		          renderer.setSize( window.innerWidth, window.innerHeight );
		          document.body.appendChild( renderer.domElement );

							//Luz
							scene.add( new THREE.AmbientLight( 0x101010 ) );
							light = new THREE.PointLight(0xffffff, 2.0, 500, 3.5);
							light.position.set(camera.position.x, camera.position.y, camera.position.z);
							scene.add(light);

							// Grade
							var line_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
								geometry = new THREE.Geometry()
								floor = 0, step = 25;

							for ( var i = 0; i <= 20; i ++ )
							{
								geometry.vertices.push( new THREE.Vector3( - 250, floor, i * step - 250 ) );
								geometry.vertices.push( new THREE.Vector3(   250, floor, i * step - 250 ) );
								geometry.vertices.push( new THREE.Vector3( i * step - 250, floor, -250 ) );
								geometry.vertices.push( new THREE.Vector3( i * step - 250, floor,  250 ) );

							}

							var line = new THREE.LineSegments( geometry, line_material );
							scene.add( line );



							for ( var i = 0; i < 100; i ++ )
							{
								addNewCube(Math.random() * 500 - 250, Math.random() * 200 + 10, Math.random() * 500 - 250);
							}

					}

          function render()
          {
							controls.update();
							var timer = 0.0001 * Date.now();
              requestAnimationFrame( render );
							light.position.set(camera.position.x, camera.position.y, camera.position.z );
							camera.lookAt( scene.position );
              renderer.render( scene, camera );
          }
          render();

          window.addEventListener('resize', function()
          {
	            var WIDTH = window.innerWidth,
	                HEIGHT = window.innerHeight;
	            renderer.setSize(WIDTH, HEIGHT);
	            camera.aspect = WIDTH / HEIGHT;
	            camera.updateProjectionMatrix();
          });


					function onDocumentMouseMove( event )
					{
							event.preventDefault();
							mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
							mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
							container.style.cursor = 'auto';
					}

					function onDocumentMouseDown( event )
					{
							event.preventDefault();
						 	container.style.cursor = 'move';
					}

					function onDocumentMouseUp( event )
					{
							event.preventDefault();
							controls.enabled = true;
							container.style.cursor = 'auto';
					}

					function addNewCube(x, y, z)
					{
						//Cubo
							var geometry = new THREE.BoxGeometry( 15, 15, 15 );
							var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

							object.position.x = x;
							object.position.y = y;
							object.position.z = z;

							object.rotation.x = Math.random() * 2 * Math.PI;
							object.rotation.y = Math.random() * 2 * Math.PI;
							object.rotation.z = Math.random() * 2 * Math.PI;

							object.castShadow = true;
							object.receiveShadow = true;

							this.scene.add( object );

							this.objects.push( object );
					}
    </script>
  </body>
</html>
