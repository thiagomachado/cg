<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cubos</title>
		<meta charset="utf-8">
		<style>
			body
      {
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
      canvas
      {
        height: 100%;
        width: 100%;
      }
		</style>
    <script src="js/three.min.js"></script>
		<script src="js/CanvasRenderer.js"></script>
		<script src="js/Projector.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/OrbitControls.js"></script>
	</head>
	<body>
    <script >

					var camera, controls, scene, renderer, light, projector;
					var objects = [];
					var raycaster;
					var mouse;
					var selectedObject;
					init();

					function init()
					{

							camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500000 );
							camera.position.set( 0, 200, 500 );

							// Verifica se tem renderer webgl, caso não tenha exibe com Canvas
							if ( Detector.webgl )
								renderer = new THREE.WebGLRenderer( {antialias:true} );
							else
								renderer = new THREE.CanvasRenderer();

							renderer.setSize( window.innerWidth, window.innerHeight );
							document.body.appendChild( renderer.domElement );


							scene = new THREE.Scene();

							//Controle de camera
							controls = new THREE.OrbitControls( camera, renderer.domElement );
							controls.enableDamping = true;
							controls.dampingFactor = 0.25;
							controls.enableZoom = true;
							controls.enablePan = false;
							controls.zoomSpeed = 0.5;

							//Luz
							scene.add( new THREE.AmbientLight( 0x010101 ) );
							light = new THREE.PointLight(0xffffff, 2.0, 700, 1.5);
							light.position.set(camera.position.x, camera.position.y, camera.position.z);
							scene.add(light);

							// Grade
							var line_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
								geometry = new THREE.Geometry()
								floor = 0, step = 25;

							for ( var i = 0; i <= 20; i ++ )
							{
								geometry.vertices.push( new THREE.Vector3( - 250, floor, i * step - 250 ) );
								geometry.vertices.push( new THREE.Vector3(   250, floor, i * step - 250 ) );
								geometry.vertices.push( new THREE.Vector3( i * step - 250, floor, -250 ) );
								geometry.vertices.push( new THREE.Vector3( i * step - 250, floor,  250 ) );

							}

							var line = new THREE.LineSegments( geometry, line_material );
							scene.add( line );

							projector = new THREE.Projector();
							raycaster = new THREE.Raycaster();
							mouse = new THREE.Vector2();

							for ( var i = 0; i < 100; i ++ )
							{
								addNewCube(Math.random() * 500 - 250, Math.random() * 200 + 10, Math.random() * 500 - 250);
							}

							//eventos
							// document.addEventListener( 'mousemove', onDocumentMouseMove, false );
							 document.addEventListener( 'mousedown', onDocumentMouseDown, false );
							 document.addEventListener( 'mouseup', onDocumentMouseUp, false );
							// document.addEventListener( 'keydown', onDocumentKeyDown, false );
							// document.addEventListener( 'keyup', onDocumentKeyUp, false );
					}

          function render()
          {
							controls.update();
							var timer = 0.0001 * Date.now();
              requestAnimationFrame( render );
							light.position.set(camera.position.x, camera.position.y, camera.position.z );
							camera.lookAt( scene.position );
              renderer.render( scene, camera );
          }
          render();

          window.addEventListener('resize', function()
          {
	            var WIDTH = window.innerWidth,
	                HEIGHT = window.innerHeight;
	            renderer.setSize(WIDTH, HEIGHT);
	            camera.aspect = WIDTH / HEIGHT;
	            camera.updateProjectionMatrix();
          });


					// function onDocumentMouseMove( event )
					// {
					// 		event.preventDefault();
					// 		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					// 		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					// 		container.style.cursor = 'auto';
					// }
					//
					// function onDocumentMouseDown( event )
					// {
					// 		event.preventDefault();
					// 	 	container.style.cursor = 'move';
					// }
					//
					// function onDocumentMouseUp( event )
					// {
					// 		event.preventDefault();
					// 		controls.enabled = true;
					// 		container.style.cursor = 'auto';
					// }

					function addNewCube(x, y, z)
					{
						//Cubo
							var geometry = new THREE.BoxGeometry( 15, 15, 15 );
							var object = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
							object.metal = true;
							object.position.x = x;
							object.position.y = y;
							object.position.z = z;

							object.rotation.x = Math.random() * 2 * Math.PI;
							object.rotation.y = Math.random() * 2 * Math.PI;
							object.rotation.z = Math.random() * 2 * Math.PI;

							object.castShadow = true;
							object.receiveShadow = true;

							this.scene.add( object );

							this.objects.push( object );
					}

					function onDocumentMouseDown( event )
					{

							event.preventDefault();
							//posição do mouse na matriz que é exibida na tela
							mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
							mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

							//vetor do ponto (x,y) no eixo z, de acordo com a posição da camera
							raycaster.setFromCamera( mouse, camera );

							//objetos que são interceptados pelo vetor em ordem de distancia, o primeiro é o mais proximo da camera
							var intersects = raycaster.intersectObjects( objects );

							if ( intersects.length > 0 )
							{
								selectedObject = intersects[0].object;
								//muda a cor do cubo selecionado
								selectedObject.material.color.setHex(0xff0000 );
								selectedObject.emissive = 0xff0000;
								selectedObject.shininess = 60;
								//desativa os controles da cena qdo seleciona um cubo
								controls.enableRotate = false;
								controls.enableZoom = false;
							}

					}
					function onDocumentMouseUp(event)
					{
						//ativa os controles da cena
						controls.enableRotate = true;
						controls.enableZoom = true;
						//volta a cor original do cubo
						selectedObject.material.color.setHex(0xffffff );
					}


    </script>
  </body>
</html>
